TODO:


[X] allow implicitly sized arrays
	[ ] handle this case: arr[] = {1,2,3,4, [10]=69};  (size is 11 here)

[ ] output line directives to the c compiler (preprocessor technically, i
    think) to allow debugging ion source code

[ ] issue warnings for conversions that could potentially lose information
    (truncations)

[ ] designated initializers ( pos := Vec3{x=6, y=9} )

[ ] think about removing var keyword, could just look ahead to see if the next
		token is ':' to tell if it is a DECL_VAR

[ ] control flow analysis, like detecting if all branches of an if statement
    return a value if they should

[ ] comments
	[X] single line
	[ ] multi line  
	
[ ] string escape chars
    [X] \n, \t, \\, \', \"
    [X] \a, \b, \e, \f, \v, \?
    [X] \xhh (hex)
    [ ] \nnn (octal)
    [ ] \uhh... (unicode or universal character names)

[ ] declarations in functions (statement declarations)
	- like an enum, or struct declared inside a function

[ ] reformat for stupid tabs vs spaces

[ ] local_syms should probably be a stretchy buffer

[ ] constant expression evaluation
    [X] binary exprs
    [X] unary exprs
    [ ] cast exprs ??

[ ] improve error messages

[ ] should string literals in var decls and init statements decay to pointer
    types or nah?? (s := "farts"; --> char *s = "farts";)



[X] hash table
  [X] replace the linear search in str_intern
  [X] replace other naive linear searches
[X] compound literals: generate explicit type "cast" in c-syntax only when
    compound literal is used in a non initializer context
[x] handle compound literal arrays in implicit contexts like a function call
    right now it decays to a ptr and so type checking fails
[X] profiling (tried out superluminal, it is nice) confirms that
    str_intern_range is the hottest function in the program. speed it up with a
    hashmap
[X] issues with warnings being printed to stdout when redirecting output of
    compilation to a file. should probably separate errors/warnings to printing
    to stderr
[X] types for hex and oct literals need to grow to unsigned if necessary, see c
    spec section 6.4.4.1
[X] evaluate constants that are binary or unary expressions
    e.g.  const n0 = 1 + sizeof(p0);
[X] when casting, if type is const, need to do type conversion of the constant
    value (possible truncation)
[X] implicit break for switch cases
	[X] support commas in switch cases for multiple case expressions to use the
			same block, this alleviates need for fallthrough
[X] resolving constants
	[X] integer (see c standard section 6.4.4.1)
	[x] floats
	[X] doubles with d suffix
	[X] character
  [X] octal constants
  [X] binary constants
  [X] hex constants
[X] implement the different integer types (uint, etc.)
[X] integer promotions and implicit conversions 
	[X] binary expressions
	[X] ternary exprs
	[X] var decls
	[X] init stmts
	[X] assignment stmts
	[X] compound exprs
	[X] function calls
	[X] switch expr
	[X] switch case exprs
	[X] condition exprs (if, for, do/while, ternary)
[X] in ast nodes, be consistent about calling things typespec always when they
    are Typespec to differentiate from Type
[X] array pointer decay
[X] move true and false to symbol table instead of keywords
[X] built in NULL 
[X] creating bindings to c functions like printf
[X] the backpointer from type to its symbol not being set correctly
[X] character literals
[\] var args (...)
	[X] enforce at least one param must precede ... 
	[X] enforce ... must be last argument
[X] c codegen
	[X] forward declaring struct, union, enums
	[X] functions
	[X] statements
	[X] constants
	[X] use gen_typespec_c wherever possible to retain more syntactic information
			(for example an expression for an array size rather than just a resolved constant value)
[X] fix source position calculation
[X] resolving typedefs
[X] resolving enums
[X] parse and resolve strings
[X] handle bools and the identifiers true and false
[X] tracking source code position (line and column)
[X] compile from a source code file
[X] type size and alignment
[X] resolve function typespecs
[X] type inference
	[X] handle var decls that dont have an explicit type, these can infer the type
      from the expr.
	[X] function args in call  
[X] type checking
	[X] function arguments in a call
	[X] compound literal args
	[X] return type
[X] resolving function bodies (statements)
[X] scoped symbols (ex: variables in function bodies)
[X] fill out expression resolution 
	[X] binary
	[X] ternary
	[X] cast
	[X] call
	[X] index
	[X] field
[X] remove redundant expr kinds: "EXPR_OR, EXPR_AND, EXPR_CMP"
[X] replace system allocations with arena allocator
[X] order independent declarations
[X] type resolution, type checking
[X] replace instances of fatal() with syntax_error() where appropriate. fatal is useful now in early development 


2023-05-29
--------------------------------------------------------------------------------
Implicit Sized Arrays

Today I implemented implicit sized arrays in var declarationss and init
statements. After trying a couple of approaches, I settled on the following:
- in parse_typespec(), if you encounter [], allow the size expression to be NULL
- in resolve_typespec() for TYPESPEC_ARRAY, if the size expresssion is NULL,
  then construct an array type with size zero
- in resolve_expr_expected() for EXPR_COMPOUND, check if the typespec or
  expected type have an array size of 0, and if so create a new array type,
  whose size is determined by the number of args in the compound expression

In the other approaches I was trying, I was handling implicit sized arrays in
resolve_decl_var() and resolve_stmt() for STMT_INIT, and not resolving typespecs
with no array size. This had issues when trying to resolve the compound
expression (array initializer) and potentially pass an expected type. The reason
I ultimately went with the approach I outlined above is so that implicit sized
arrays can be used in any typespec context using the same codepath, for example: 
- var arr: int[] = { 1, 2, 3 };
- var arr := (:int[]){ 1, 2, 3 };


One thing I don't like about this, is that creating an array type with size 0
caches that type that will ultimately not be used and will take up space in the
cache. I was thinking I could do some kind of incomplete type for arrays or
maybe a separate type constructor that doesn't cache it and acts like a dummy
type just to allow compound expressions to have an expected type to use,
essentially just to get the array element type. I am not sure. However, the
extra cached array types should only potentially be a problem if many implicitly
sized arrays of different types are used in the program. Note that at the
moment cached types are just using dynamic arrays, so the impact of useless
cached types is worse, since a cache lookup is a linear search. However, this is
intended to be replaced by a hashmap in the future anyway so I am not
necessarily worried about that.


For posterity, one of the previous implementation attempts was like this:

Type *resolve_decl_var(Decl *decl) {
	assert(decl->kind == DECL_VAR);
	Typespec *typespec = decl->var.typespec;
	Expr *init_expr = decl->var.expr;
	Type *type = NULL;
	if (typespec) {
		// allow implicit sized array typespec
		if (typespec->kind == TYPESPEC_ARRAY && typespec->array.num_items == NULL) {
			if (!init_expr || init_expr->kind != EXPR_COMPOUND) {
				semantic_error(decl->pos, "implicit sized array must have an initializer expression");
			} else {
				Type *elem_type = resolve_typespec(typespec->array.base);
				type = type_array(elem_type, init_expr->compound.num_args);
			}
		} else {
			type = resolve_typespec(typespec);
		}
	}

	if (init_expr) {
		ResolvedExpr resolved = resolve_expr_expected(init_expr, type);
		if (resolved.type->kind == TYPE_ARRAY && init_expr->kind != EXPR_COMPOUND) {
			pointer_decay(&resolved);
		}

		if (!type) {
			type = resolved.type;
		} else if (resolved.type != type) {
			if (!convert_operand(&resolved, type)) {
				semantic_error(decl->pos, 
					"type mismatch in var declaration: specified type is %s, expression type is %s",
					type_to_str(type), type_to_str(resolved.type));
			}
		}
		init_expr->type = type;
	}

	return type;
}




2023-05-14
--------------------------------------------------------------------------------

When resolving, we want to pass type information on to the code generator. Right
now the type info only lives in symbols. In Bitwise video day 10 and the extra
stream, Per adds type info to expressions (a Type *) and also adds to Decls a
symbol pointer. He says he wants to do this so that the generator has type
information, but it is not yet clear to me when this will be used. i.e when do
you need type information directly from an expr or symbol directly from a decl.

Okay after trying to write the c code generation myself I now see that type info
needs to be stored in expressions to account for inferred types. For example
init statments like count := 0; this statement has no typespec field, so the
type needs to be inferred from the rhs. The type is found during resolution, but
needs to be passed on to code generation, so storing it in the expression is how
we will do this.


- Some symbols, like built ins, don't have associated declarations, so we need to
  skip over these when generating forward decls in c code generator for example.



2023-03-15
--------------------------------------------------------------------------------
Resolution / Binding

When resolving a declaration (e.g. a struct), there are two possible scenarios:
1. we encountered the definition
  - resolve the symbol AND complete the type
2. we encountered some other usage
  - resolve the symbol, but only complete types if we actually need the 
    complete type at this moment





2023-03-08
--------------------------------------------------------------------------------
Symbol Resolution


What does it mean to "resolve" a symbol?

there are two kinds of "resolution" happening
1 discovering dependencies
2 type completion

a dependency on a particular symbol does not necessarily mean it must be ordered
before you, only if it trys to use the symbol in a way that it needs to know the
full definition of the thing is the type completed and the symbol put into the
ordered symbol list


concrete example, symbol of kind SYM_VAR
- discover the type of the var sym and either create a new type or associate it
  with the already created canonical version of that type
- discover what symbols that the var sym depends on
  (resolve the rhs expression)
- make sure that the rhs expression (if it exists) matches the type of the lhs
- if the rhs is a constant, evaluate it and store that somewhere
- detect cycles
  i.e. var x: int = x;


struct x { v: Vec3; }

SYM_TYPE
struct, union
- create a new type and associate it with the symbol
- iterate over the fields and discover dependencies
  (resolve the type of each field)
- make sure fields have unique names
- ensure there are some fields at all
- ensure no duplicate definitions




structs and unions, the moment a symbol is created for them, they are resolved
in other words they begin life resolved (SYM_RESOLVED)
however they are not put into the ordered symbols list, until they are COMPLETED




2023-03-08
--------------------------------------------------------------------------------
Order Independent Declarations

The simple, but shallow approach of just ordering declarations based on walking
their dependencies failed. The reason was the dependecies that were only on a pointer
to a thing and not its value. There are cases like the following where it falls
apart:

const x = sizeof(*p);
var p: T*;
struct T { ... }

Here p only depends on T through a pointer so it does not have to be ordered
before it. However x depends on p and deferences it so actually depends on T as
a value. This sort of "transitivity" issue can not be solved with the simple
shallow walking of dependencies.


The new approach is the following:

- Parse a bunch of declarations
- create a new symbol for each decl, and add it to a symbol table
  (a symbol is basically a package level binding)
- iterate through all the symbols and recursively resolve everything
  adding them to a list of ordered symbols
- 


resolving a typespec is turning the syntactic typespec into a semantic type

structs and union types will always start out as TYPE_INCOMPLETE, then only when
in a situation where the complete type is explicitly needed do we finish
"completing" the type


2023-03-06
--------------------------------------------------------------------------------
Order Independent Declarations

1. Create a symbol table which maps names to declarations

2. iterate over the symbol table and order the declarations

3. Order:
   if ordered, return the ordered decl
   if unordered, set to ordering and recursively order it
   if ordering, there is a cycle, print error


2023-02-07
--------------------------------------------------------------------------------
Current Video: Bitwise Day 8

Lexing
- transform a stream of characters into a stream of tokens

Parsing
- transform a stream of tokens into an AST
- An ast node corresponds to a grammar production rule

Resolving Symbols/Entities
- order independent declarations
- cyclic dependency detection
- constant expression evaluation
- type checking/inference


--------------------------------------------------------------------------------

How It Works


Ion Compiler High Level Algorithm
1. Parse a bunch of declarations corresponding to a package
2. Create a new symbol for each decl, and add it to a symbol table
   (a symbol is basically a package level binding)
3. Iterate through all symbols and resolve each one recursively, adding them to
   a list of ordered symbols 


What does it mean to "resolve" a symbol?
There are two kinds of "resolution" happening:
1. Discovering dependencies and ordering
2. Type completion


TODO
Order Independent Declarations


A dependency on a particular symbol does not necessarily mean that it must
precede in the ordering, only if the symbol is used in a way that its full
definition must be known is the type completed and the symbol put into the
ordered symbol list.  For example, a dependency on a pointer to a type does not
require the type to precede in the ordering, but a dependency on a type as a
value does require it to precede.



incomplete types - aggregate types begin their life as incomplete types. as
resolution proceeds, types are sort of lazily resolved where fields are only
resolved at the time of first use, 

there are two types of resolving going on: declaration level ordering and stuff,
and then type level dependency resolution



difference in Type and Typespec?

resolving a typespec is turning the syntactic typespec into a semantic type

A "Type" is an interned, canonical version of a type that can be compared
directly with pointers 

A "Typespec" is sort of like a reference to a type. 

One illustrative example is an array type:
The following is a typespec, where the size of the array is an expression:
var arr: int[const1 + const2];

Once this is resolved into a type, the size of the array must be resolved into a
constant value. So if the values of const1 and const2 are 10 and 6, the type
would be:
var arr: int[16];





